# TimeseriesWorkload:
# 1 collection with 9 indexes created and dropped / second
#  * HardLimits describe (latency) requirements that must be met. If one fails, test exits immediately.
#  * Inserts, if non-zero, go to the most recent collection, others are read-only
#  * Each of collection lives for an hour
#  * Queries are rarer and larger as collections get older

Pool:
  QueryOptions:
    maxPoolSize: 1000
Actors:
    # This actor creates and drops collections at a given rate, and optionally executes
    # inserts and queries against them too.
  - Type: CreateAndDropCollections
    CollectionPrefix: Collection # Collection names are Collection0, Collection1...
    CollectionCount: 3600 # Note: This means that only after creating Collection3600 will Collection0 be dropped
    # *PerHour instead of per second to avoid small fractions.
    # TBD: What should happen if each create and drop takes 2 seconds?
    CreatesPerHour: 3600 # per hour
    DropsPerHour: 3600

    HardLimits:
        Create:
            Latency: 3 seconds
            SLA: 99.5
        Drop:
            Latency: 3 seconds
            SLA: 99.5



    # Inserts insert documents generated as defined by Document: below
    Inserts:
      - TargetRate: 500
    Queries:
        # The first query finds a single record, high concurrency and targets the most recent collections
      - TargetRate: 1000
        # Integer to subtract from the most recent collection nr.
        # Example: Collection3601 - 2 => Collection3599
        CollectionOffset: {^RandomInt: {distribution: geometric, p: 0.9}}
        Filter: {y: {^RandomInt: {distribution: poisson, mean: 100}}}
        # The second query is a range scan, lower concurrency and targets a broader set of collections
      - TargetRate: 10
        CollectionOffset: {^RandomInt: {distribution: geometric, p: 0.1}}
        Filter: { int3: { $gt : {^RandomInt: {distribution: poisson, mean: 100}}, $lt: "SAME RandomInt AS IN THE $gt AND ADD +1000"   }

    Phases:
      - Duration: 5 minutes


    # Below was just copy pasted from Load.yml
    # TBD: If we want to emulate a timeseries workload, probably less indexes and in particular append only inserts to indexes is better.
    Document:  # Documents are approximately 1 KiB in size
      t: {^RandomInt: {min: 0, max: 10}}
      w: {^RandomInt: {distribution: geometric, p: 0.1}}
      x: 0
      y: {^RandomInt: {min: 0, max: 1000}}
      z: {^RandomInt: {min: 0, max: 2147483647}}  # This is for max int for low probability of conflicts
      int0: &int {^RandomInt: {distribution: binomial, t: 200, p: 0.5}}
      int1: *int
      int2: *int
      int3: *int
      int4: *int
      int5: *int
      int6: *int
      int7: *int
      int8: *int
      int9: *int
      # Note -- genny does not support value generation within lists
      # yet. https://jira.mongodb.org/browse/TIG-1245
      intArray:
        - 1000
        - 2000
        - 3000
        - 4000
        - 5000
        - 6000
        - 7000
        - 8000
        - 9000
      string0: &string {^RandomString: {length: {^RandomInt: {min: 5, max: 15}}}}
      string1: *string
      string2: *string
      string3: *string
      string4: *string
      string5: *string
      string6: *string
      string7: *string
      string8: *string
      string9: *string
      stringShort: {^RandomString: {length: 1}}
      stringLong: {^RandomString: {length: 100}}
      compressibleStringArray:
        - &cstring AAAAAAAAAAAAAAAAAAAA
        - *cstring
        - *cstring
        - *cstring
        - *cstring
        - *cstring
        - *cstring
        - *cstring
        - *cstring
        - *cstring
      some: {embedded: {document: {with: {some: {depth: *string}}}}}
    # The Loader needs to be updated to take options to support unique, etc. I will do as a
    # follow-up. PERF-1758
    Indexes:
      - keys: {t: 1, w: 1}
      - keys: {y: 1}
      - keys: {t: 1, stringShort: 1}
      - keys: {string0: 1}
      - keys: {stringLong: 1}
        options: {unique: 1}
      - keys: {stringShort: 1, y: 1}
      - keys: {int0: 1, int1: 1, int2: 1}
      - keys: {int3: 1}
      - keys: {int4: 1}
      - keys: {int5: 1, int6: 1}
